using System;
using System.Collections;

namespace Algorithms
{
    //Найти все возможные суммы массива
    public static class Task9
    {
        public static void Func(int[] arr)
        {
            //Идея:
            //Число всех вариантов сумм чисел массива arr будет равно 2^arr.Length.
            //Каждое число из 2^arr.Length можно представить в двоичной системе. Например, 1 => 0..00001, 2 => 0..00011, и т.д.
            //Если рассмотреть двоичные представления этих чисел и спроецировать на массив, 
            //то мы получим всевозможные варианты сумм чисел массива. Т.е. если нулевой элемент двоичного представления = 1,
            //то мы к сумме прибавляем нулевой элемент массива, если = 0, то не прибавляем.
            //00001 => arr[5];
            //00011 => arr[4] + arr[5];
            //..

            //Создаём переменную, в которой хранится количество всех вариантов сумм массива arr.
            var count = Math.Pow(2, arr.Length);
            //Эта переменная нужна для цикла. "/2" для сокращения шагов.
            var tmp = (count) / 2;
            //Создаём массив для хранения всех сумм.
            var resArr = new int[(int)count];
            //Запускаем цикл по всем вариантам сумм.
            for (var i = 0; i < tmp; i++)
            {
                //Записываем двоичное представление "номера" суммы элементов массива.
                var b = new BitArray(new[] { i });
                //Цикл по каждому биту "номера" суммы.
                //Ограничение в arr.Length потому, что для представления 2^arr.Length чисел, требуется arr.Length бит.
                for (var j = 0; j < arr.Length; j++)
                {
                    //Проверяем каждый бит. 
                    if (b[j])
                        //Если он =1, то прибавляем к текущей сумме.
                        resArr[i] += arr[j];
                    else
                        //Если он =0, то прибавляем к зеркальной сумме.
                        resArr[resArr.Length-1-i] += arr[j];
                    //Т.е. если мы рассматриваем сумму под номером 1, то битовое представление этого номера будет 00001, 
                    //но так же есть сумма под номером 30 => 11110, которая является зеркальной для первой.
                    //Т.о. можно уменьшить количество шагов в 2 раза.
                }

            }
            foreach (var res in resArr)
            {
                Console.WriteLine(res);
            }
        }
    }
}